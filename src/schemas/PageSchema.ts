import { z } from 'zod';
import { ContentEntrySchema } from './ContentEntry';

export const PAGES_COLLECTION_NAME = 'pages';

export const PageSchema = ContentEntrySchema.extend({
  name: z.string(),
  siteKey: z.string(),
  /**
   * Legacy content field, should be handled SSR side.
   */
  content: z.string().optional(),
  category: z.string().optional(),
  revisionCount: z.coerce.number().default(0),
  previousRevisionKey: z.string().optional(),
});

export const PageRevisionSchema = z.object({
  key: z.string(),
  /**
   * The patch string generated by diff-match-patch.
   * When applied to the full markdown content of the version that *followed* this one,
   * it reconstructs the full markdown content of this_version_conceptual_id.
   */
  patch_to_reconstruct: z.string(),
  /**
   * The uid of the user that created this revision.
   */
  author: z.string(),
  /**
   * The date when this revision was created.
   */
  createdAt: z.coerce.date(),
  /**
   * Comments if any.
   */
  comments: z.string().optional(),
});

export type Page = z.infer<typeof PageSchema>;
export type PageRevision = z.infer<typeof PageRevisionSchema>;

/* export const parsePage = (
  data: Partial<Page>,
  key = '',
  siteKey = '',
): Page => {
  const revisionHistory = [];
  if (data.revisionHistory && Array.isArray(data.revisionHistory)) {
    for (const revision of data.revisionHistory) {
      const { author, createdAt, markdownContent } = revision;
      revisionHistory.push({
        author,
        markdownContent,
        createdAt: toDate(createdAt),
      });
    }
  }

  try {
    return PageSchema.parse({
      ...data,
      siteKey:
        data.siteKey && typeof data.siteKey === 'string'
          ? data.siteKey
          : siteKey,
      owners:
        typeof data.owners === 'string'
          ? [data.owners]
          : data.owners
            ? data.owners
            : [],
      flowTime: toDate(data.flowTime).getTime(),
      key,
      revisionHistory,
      markdownContent: data.markdownContent || '',
    });
  } catch (err: unknown) {
    if (err instanceof z.ZodError) {
      logError(err.issues);
    }
    throw err;
  }
};*/

/*export function createPage(key: string, siteKey: string) {
  return parsePage(
    {
      key,
      siteKey,
      name: '',
      flowTime: new Date().getTime(),
      owners: [],
    },
    key,
    siteKey,
  );
}*/
export function pageFrom(data: Partial<Page>, key = '', siteKey = ''): Page {
  return PageSchema.parse({
    ...data,
    // Overrides
    key: key || data.key || '',
    siteKey: siteKey || data.siteKey || '',
  });
}
