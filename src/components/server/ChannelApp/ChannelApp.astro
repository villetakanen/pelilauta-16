---
import type { Channel } from '@schemas/ChannelSchema';
import { type Thread, parseThread } from '@schemas/ThreadSchema';
import { t } from '@utils/i18n';
import PaginationToolbar from './PagingToolbar.astro';
import ThreadListItem from './ThreadListItem.astro';

interface Props {
  channel: Channel;
  startAt: number;
}

const { channel, startAt } = Astro.props;
const origin = Astro.url.origin;

const queryString =
  startAt > 1
    ? `${origin}/api/threads.json?channel=${channel.slug}&limit=10&startAt=${startAt}`
    : `${origin}/api/threads.json?channel=${channel.slug}&limit=10`;

const threadListResponse = await fetch(queryString);
const threadsJSON = await threadListResponse.json();

const threads = threadsJSON.map((thread: Thread) =>
  parseThread(thread, thread.key),
);
const lastThreadFlowTime = threads[threads.length - 1]?.flowTime || 0;
const hasNextPage = threads.length === 10;

// The channel has N pages where N is the number of threads divided by 10
// and rounded up. The last page is the one that has the last thread.
const pages = Math.ceil((channel.threadCount || 0) / 10);
---
<div class="content-columns">
  <section class="column-l">
   <PaginationToolbar
     channel={channel} 
     lastThreadFlowTime={lastThreadFlowTime} 
     hasNextPage={hasNextPage}/>
     { threads.map((thread: Thread) => (
       <ThreadListItem thread={thread} />
      )) }
    <PaginationToolbar channel={channel} lastThreadFlowTime={lastThreadFlowTime} hasNextPage={hasNextPage}/>
  </section>
  <section class="column-s flex flex-col items-center surface p-2">
    <cn-icon noun={channel.icon} large />
    <h2 class="downscaled m-0">{channel.name}</h2>
    <p class="mt-0">
      {t('threads:channel.threadCount', {count: channel.threadCount})}<br />
      {t('threads:channel.pageCount', {count: pages})}</p>
    {channel.description && <p class="text-small">{channel.description}</p>}
  </section>
</div>